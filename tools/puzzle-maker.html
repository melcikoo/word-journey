<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Word Journey Crossword Puzzle Maker</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;700&family=JetBrains+Mono:wght@400;500&display=swap');

  :root {
    --bg-primary: #0f0f1a;
    --bg-secondary: #1a1a2e;
    --bg-card: #16213e;
    --bg-input: #0f3460;
    --text-primary: #e2e8f0;
    --text-secondary: #94a3b8;
    --text-muted: #64748b;
    --accent: #818cf8;
    --accent-hover: #6366f1;
    --accent-dim: rgba(129, 140, 248, 0.15);
    --success: #34d399;
    --success-dim: rgba(52, 211, 153, 0.15);
    --warning: #fbbf24;
    --warning-dim: rgba(251, 191, 36, 0.15);
    --danger: #f87171;
    --danger-dim: rgba(248, 113, 113, 0.15);
    --border: #1e293b;
    --border-light: #334155;
    --radius: 12px;
    --radius-sm: 8px;
    --shadow: 0 4px 24px rgba(0,0,0,0.3);
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    font-family: 'Noto Sans KR', -apple-system, BlinkMacSystemFont, sans-serif;
    background: var(--bg-primary);
    color: var(--text-primary);
    line-height: 1.6;
    min-height: 100vh;
  }

  /* Header */
  .header {
    background: var(--bg-secondary);
    border-bottom: 1px solid var(--border);
    padding: 16px 24px;
    display: flex;
    align-items: center;
    gap: 16px;
    position: sticky;
    top: 0;
    z-index: 100;
  }
  .header h1 {
    font-size: 18px;
    font-weight: 700;
    background: linear-gradient(135deg, var(--accent), #a78bfa);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
  }
  .header .version {
    font-size: 12px;
    color: var(--text-muted);
    background: var(--bg-card);
    padding: 2px 8px;
    border-radius: 4px;
  }
  .header-right {
    margin-left: auto;
    display: flex;
    align-items: center;
    gap: 12px;
  }

  /* Layout */
  .container {
    display: flex;
    gap: 0;
    min-height: calc(100vh - 57px);
  }
  .left-panel {
    width: 420px;
    min-width: 420px;
    background: var(--bg-secondary);
    border-right: 1px solid var(--border);
    overflow-y: auto;
    padding: 20px;
    display: flex;
    flex-direction: column;
    gap: 16px;
  }
  .right-panel {
    flex: 1;
    padding: 20px;
    overflow-y: auto;
    display: flex;
    flex-direction: column;
    gap: 20px;
  }

  /* Cards */
  .card {
    background: var(--bg-card);
    border: 1px solid var(--border);
    border-radius: var(--radius);
    overflow: hidden;
  }
  .card-header {
    padding: 14px 18px;
    border-bottom: 1px solid var(--border);
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 8px;
  }
  .card-header h2 {
    font-size: 14px;
    font-weight: 700;
    display: flex;
    align-items: center;
    gap: 8px;
  }
  .card-header .step-badge {
    font-size: 10px;
    font-weight: 700;
    padding: 2px 8px;
    border-radius: 10px;
    background: var(--accent-dim);
    color: var(--accent);
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }
  .card-body {
    padding: 18px;
  }

  /* Form groups */
  .form-group {
    margin-bottom: 14px;
  }
  .form-group:last-child {
    margin-bottom: 0;
  }
  .form-group label {
    display: block;
    font-size: 12px;
    font-weight: 500;
    color: var(--text-secondary);
    margin-bottom: 6px;
  }
  .form-group label .hint {
    color: var(--text-muted);
    font-weight: 400;
    margin-left: 4px;
  }

  /* Inputs */
  input[type="text"],
  input[type="number"],
  input[type="color"],
  input[type="url"],
  textarea,
  select {
    width: 100%;
    padding: 10px 14px;
    background: var(--bg-input);
    border: 1px solid var(--border-light);
    border-radius: var(--radius-sm);
    color: var(--text-primary);
    font-size: 14px;
    font-family: inherit;
    transition: border-color 0.2s;
  }
  input:focus, textarea:focus, select:focus {
    outline: none;
    border-color: var(--accent);
    box-shadow: 0 0 0 3px var(--accent-dim);
  }
  input[type="color"] {
    padding: 4px;
    height: 42px;
    cursor: pointer;
  }
  textarea {
    resize: vertical;
    min-height: 80px;
  }
  select {
    cursor: pointer;
    appearance: none;
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' fill='%2394a3b8'%3E%3Cpath d='M6 8L1 3h10z'/%3E%3C/svg%3E");
    background-repeat: no-repeat;
    background-position: right 12px center;
    padding-right: 32px;
  }

  /* Buttons */
  .btn {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    padding: 10px 20px;
    border: none;
    border-radius: var(--radius-sm);
    font-size: 14px;
    font-weight: 500;
    font-family: inherit;
    cursor: pointer;
    transition: all 0.2s;
    white-space: nowrap;
  }
  .btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }
  .btn-primary {
    background: var(--accent);
    color: white;
  }
  .btn-primary:hover:not(:disabled) {
    background: var(--accent-hover);
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(99, 102, 241, 0.3);
  }
  .btn-secondary {
    background: var(--bg-input);
    color: var(--text-primary);
    border: 1px solid var(--border-light);
  }
  .btn-secondary:hover:not(:disabled) {
    background: var(--border-light);
  }
  .btn-success {
    background: var(--success);
    color: #0f172a;
  }
  .btn-success:hover:not(:disabled) {
    background: #10b981;
    transform: translateY(-1px);
  }
  .btn-danger {
    background: var(--danger);
    color: white;
  }
  .btn-danger:hover:not(:disabled) {
    background: #ef4444;
  }
  .btn-warning {
    background: var(--warning);
    color: #0f172a;
  }
  .btn-sm {
    padding: 6px 12px;
    font-size: 12px;
  }
  .btn-block {
    width: 100%;
    justify-content: center;
  }

  /* Word entries */
  .word-list {
    display: flex;
    flex-direction: column;
    gap: 10px;
  }
  .word-entry {
    background: var(--bg-primary);
    border: 1px solid var(--border);
    border-radius: var(--radius-sm);
    padding: 12px;
    position: relative;
  }
  .word-entry .word-row {
    display: flex;
    gap: 8px;
    margin-bottom: 8px;
    align-items: center;
  }
  .word-entry .word-num {
    font-size: 11px;
    font-weight: 700;
    color: var(--accent);
    min-width: 18px;
    text-align: center;
    line-height: 30px;
  }
  .word-entry input {
    flex: 1;
    padding: 6px 10px;
    font-size: 13px;
  }
  .word-entry .word-input {
    max-width: 90px;
    font-weight: 700;
  }
  .word-entry .clue-input {
    flex: 2;
  }
  .word-entry .hint2-input {
    flex: 2;
  }
  .word-entry .remove-btn {
    background: none;
    border: none;
    color: var(--danger);
    cursor: pointer;
    font-size: 16px;
    padding: 4px;
    opacity: 0.6;
    transition: opacity 0.2s;
  }
  .word-entry .remove-btn:hover {
    opacity: 1;
  }

  /* Grid display */
  .grid-wrapper {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 16px;
  }
  .grid-container {
    display: inline-grid;
    gap: 2px;
    background: var(--border);
    padding: 2px;
    border-radius: var(--radius-sm);
  }
  .cell {
    width: 48px;
    height: 48px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 20px;
    font-weight: 700;
    border-radius: 3px;
    position: relative;
    transition: all 0.2s;
  }
  .cell.filled {
    background: var(--bg-card);
    color: var(--text-primary);
  }
  .cell.filled.hidden-answer {
    color: transparent;
  }
  .cell.empty {
    background: var(--bg-primary);
    opacity: 0.3;
  }
  .cell.intersection {
    background: var(--accent-dim);
    border: 1px solid var(--accent);
  }
  .cell .cell-num {
    position: absolute;
    top: 2px;
    left: 4px;
    font-size: 9px;
    color: var(--text-muted);
    font-weight: 500;
  }

  /* Clue list in right panel */
  .clues-section {
    display: flex;
    gap: 24px;
    flex-wrap: wrap;
  }
  .clue-group {
    flex: 1;
    min-width: 250px;
  }
  .clue-group h3 {
    font-size: 13px;
    font-weight: 700;
    color: var(--accent);
    text-transform: uppercase;
    letter-spacing: 1px;
    margin-bottom: 12px;
    padding-bottom: 8px;
    border-bottom: 2px solid var(--accent-dim);
  }
  .clue-item {
    padding: 10px 12px;
    margin-bottom: 8px;
    background: var(--bg-card);
    border-radius: var(--radius-sm);
    border-left: 3px solid var(--border-light);
  }
  .clue-item .clue-word {
    font-weight: 700;
    font-size: 14px;
    color: var(--accent);
  }
  .clue-item .clue-text {
    font-size: 13px;
    color: var(--text-secondary);
    margin-top: 2px;
  }
  .clue-item .clue-hint2 {
    font-size: 12px;
    color: var(--text-muted);
    margin-top: 2px;
    font-style: italic;
  }

  /* Status / alerts */
  .alert {
    padding: 12px 16px;
    border-radius: var(--radius-sm);
    font-size: 13px;
    display: flex;
    align-items: flex-start;
    gap: 8px;
  }
  .alert-info {
    background: var(--accent-dim);
    color: var(--accent);
    border: 1px solid rgba(129, 140, 248, 0.3);
  }
  .alert-success {
    background: var(--success-dim);
    color: var(--success);
    border: 1px solid rgba(52, 211, 153, 0.3);
  }
  .alert-warning {
    background: var(--warning-dim);
    color: var(--warning);
    border: 1px solid rgba(251, 191, 36, 0.3);
  }
  .alert-danger {
    background: var(--danger-dim);
    color: var(--danger);
    border: 1px solid rgba(248, 113, 113, 0.3);
  }

  /* Toggle */
  .toggle-row {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 10px;
    padding: 8px;
  }
  .toggle-label {
    font-size: 13px;
    color: var(--text-secondary);
  }
  .toggle {
    position: relative;
    width: 40px;
    height: 22px;
  }
  .toggle input {
    opacity: 0;
    width: 0;
    height: 0;
  }
  .toggle-slider {
    position: absolute;
    cursor: pointer;
    top: 0; left: 0; right: 0; bottom: 0;
    background: var(--bg-input);
    border-radius: 22px;
    transition: 0.2s;
  }
  .toggle-slider:before {
    content: '';
    position: absolute;
    height: 16px;
    width: 16px;
    left: 3px;
    bottom: 3px;
    background: var(--text-secondary);
    border-radius: 50%;
    transition: 0.2s;
  }
  .toggle input:checked + .toggle-slider {
    background: var(--accent);
  }
  .toggle input:checked + .toggle-slider:before {
    transform: translateX(18px);
    background: white;
  }

  /* Inline row */
  .inline-row {
    display: flex;
    gap: 8px;
    align-items: flex-end;
  }
  .inline-row .form-group {
    flex: 1;
  }

  /* Button group */
  .btn-group {
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
  }

  /* Loading spinner */
  .spinner {
    display: inline-block;
    width: 16px;
    height: 16px;
    border: 2px solid rgba(255,255,255,0.3);
    border-radius: 50%;
    border-top-color: white;
    animation: spin 0.8s linear infinite;
  }
  @keyframes spin {
    to { transform: rotate(360deg); }
  }

  /* Empty state */
  .empty-state {
    text-align: center;
    padding: 60px 20px;
    color: var(--text-muted);
  }
  .empty-state .icon {
    font-size: 48px;
    margin-bottom: 16px;
    opacity: 0.5;
  }
  .empty-state h3 {
    font-size: 16px;
    color: var(--text-secondary);
    margin-bottom: 8px;
  }
  .empty-state p {
    font-size: 13px;
    max-width: 320px;
    margin: 0 auto;
  }

  /* File drop zone */
  .drop-zone {
    border: 2px dashed var(--border-light);
    border-radius: var(--radius-sm);
    padding: 20px;
    text-align: center;
    cursor: pointer;
    transition: all 0.2s;
  }
  .drop-zone:hover, .drop-zone.drag-over {
    border-color: var(--accent);
    background: var(--accent-dim);
  }
  .drop-zone p {
    font-size: 13px;
    color: var(--text-secondary);
  }
  .drop-zone .icon {
    font-size: 24px;
    margin-bottom: 8px;
  }

  /* Settings row */
  .settings-row {
    display: flex;
    gap: 10px;
  }
  .settings-row .form-group {
    flex: 1;
  }

  /* JSON preview */
  .json-preview {
    background: var(--bg-primary);
    border: 1px solid var(--border);
    border-radius: var(--radius-sm);
    padding: 16px;
    font-family: 'JetBrains Mono', monospace;
    font-size: 11px;
    line-height: 1.5;
    overflow-x: auto;
    max-height: 400px;
    overflow-y: auto;
    color: var(--text-secondary);
    white-space: pre;
  }

  /* Color input wrapper */
  .color-input-wrap {
    display: flex;
    gap: 8px;
    align-items: center;
  }
  .color-input-wrap input[type="color"] {
    width: 42px;
    min-width: 42px;
    padding: 2px;
  }
  .color-input-wrap input[type="text"] {
    flex: 1;
  }

  /* Scrollbar */
  ::-webkit-scrollbar { width: 6px; }
  ::-webkit-scrollbar-track { background: transparent; }
  ::-webkit-scrollbar-thumb { background: var(--border-light); border-radius: 3px; }
  ::-webkit-scrollbar-thumb:hover { background: var(--text-muted); }

  /* Toast notification */
  .toast {
    position: fixed;
    bottom: 24px;
    right: 24px;
    background: var(--bg-card);
    border: 1px solid var(--border);
    border-radius: var(--radius-sm);
    padding: 14px 20px;
    font-size: 13px;
    box-shadow: var(--shadow);
    z-index: 1000;
    transform: translateY(100px);
    opacity: 0;
    transition: all 0.3s ease;
  }
  .toast.show {
    transform: translateY(0);
    opacity: 1;
  }

  /* Responsive */
  @media (max-width: 900px) {
    .container {
      flex-direction: column;
    }
    .left-panel {
      width: 100%;
      min-width: 0;
      max-height: 50vh;
    }
  }
</style>
</head>
<body>

<!-- Header -->
<div class="header">
  <h1>Word Journey Crossword Maker</h1>
  <span class="version">v2.0</span>
  <div class="header-right">
    <button class="btn btn-secondary btn-sm" onclick="downloadTemplate()">JSON Template</button>
  </div>
</div>

<!-- Main layout -->
<div class="container">
  <!-- LEFT PANEL -->
  <div class="left-panel">

    <!-- Step 1: Narrative Input -->
    <div class="card">
      <div class="card-header">
        <h2><span class="step-badge">Step 1</span> Narrative Text</h2>
      </div>
      <div class="card-body">
        <div class="form-group">
          <label>AI API Key <span class="hint">(Anthropic)</span></label>
          <input type="text" id="apiKey" placeholder="sk-ant-api03-..." autocomplete="off">
        </div>
        <div class="form-group">
          <label>Narrative (Korean)</label>
          <textarea id="narrativeInput" rows="5" placeholder="서사를 입력하세요...&#10;예: 텅 빈 새벽, 창밖엔 잿빛 하늘이 무심하게 펼쳐져 있었다."></textarea>
        </div>
        <div class="settings-row">
          <div class="form-group">
            <label>Difficulty</label>
            <select id="difficultySelect">
              <option value="1">1 - Easy</option>
              <option value="2">2 - Normal</option>
              <option value="3" selected>3 - Medium</option>
              <option value="4">4 - Hard</option>
              <option value="5">5 - Expert</option>
            </select>
          </div>
          <div class="form-group">
            <label>Grid Size</label>
            <select id="gridSizeSelect">
              <option value="5">5 x 5</option>
              <option value="6">6 x 6</option>
              <option value="7" selected>7 x 7</option>
              <option value="8">8 x 8</option>
              <option value="9">9 x 9</option>
              <option value="10">10 x 10</option>
            </select>
          </div>
          <div class="form-group">
            <label>Word Count</label>
            <input type="number" id="wordCountInput" value="5" min="2" max="15" style="width:100%">
          </div>
        </div>
        <button class="btn btn-primary btn-block" id="aiExtractBtn" onclick="aiExtractWords()">
          AI Extract Words
        </button>
        <div id="aiStatus" style="margin-top:10px;display:none;"></div>

        <div style="margin-top:12px;">
          <div class="drop-zone" id="dropZone" onclick="document.getElementById('fileInput').click()">
            <div class="icon">Upload</div>
            <p>Drop JSON file or click to upload word list</p>
          </div>
          <input type="file" id="fileInput" accept=".json,.txt" style="display:none" onchange="handleFileUpload(event)">
        </div>
      </div>
    </div>

    <!-- Step 2: Word List -->
    <div class="card">
      <div class="card-header">
        <h2><span class="step-badge">Step 2</span> Words &amp; Clues</h2>
        <button class="btn btn-secondary btn-sm" onclick="addWordEntry()">+ Add Word</button>
      </div>
      <div class="card-body">
        <div class="word-list" id="wordList">
          <!-- Word entries will be added here -->
        </div>
        <div style="margin-top:14px;">
          <button class="btn btn-success btn-block" id="generateBtn" onclick="generatePuzzle()">
            Generate Crossword
          </button>
        </div>
        <div id="generateStatus" style="margin-top:10px;display:none;"></div>
      </div>
    </div>

    <!-- Step 3: Word Journey Export -->
    <div class="card" id="exportCard" style="display:none;">
      <div class="card-header">
        <h2><span class="step-badge">Step 3</span> Word Journey Export</h2>
      </div>
      <div class="card-body">
        <div class="inline-row">
          <div class="form-group">
            <label>Chapter ID</label>
            <input type="number" id="chapterId" value="11" min="1">
          </div>
          <div class="form-group">
            <label>avatarMood</label>
            <select id="avatarMood">
              <option value="0">0 - Sadness</option>
              <option value="1">1 - Curiosity</option>
              <option value="2">2 - Hope</option>
              <option value="3">3 - Light</option>
            </select>
          </div>
        </div>
        <div class="form-group">
          <label>Chapter Title</label>
          <input type="text" id="chapterTitle" placeholder="Title">
        </div>
        <div class="form-group">
          <label>Chapter Subtitle</label>
          <input type="text" id="chapterSubtitle" placeholder="Subtitle">
        </div>
        <div class="form-group">
          <label>accentColor</label>
          <div class="color-input-wrap">
            <input type="color" id="accentColorPicker" value="#818cf8" onchange="document.getElementById('accentColorText').value=this.value">
            <input type="text" id="accentColorText" value="#818cf8" onchange="document.getElementById('accentColorPicker').value=this.value">
          </div>
        </div>
        <div class="form-group">
          <label>completionIllust <span class="hint">(emoji)</span></label>
          <input type="text" id="completionIllust" value="✨" placeholder="✨">
        </div>
        <div class="form-group">
          <label>completionNarrative</label>
          <textarea id="completionNarrative" rows="3" placeholder="Completion narrative text..."></textarea>
        </div>
        <div class="inline-row">
          <div class="form-group">
            <label>collectibleWord</label>
            <select id="collectibleWord">
              <option value="">-- Select --</option>
            </select>
          </div>
          <div class="form-group">
            <label>collectibleRarity</label>
            <select id="collectibleRarity">
              <option value="common">common</option>
              <option value="uncommon" selected>uncommon</option>
              <option value="rare">rare</option>
              <option value="legendary">legendary</option>
            </select>
          </div>
        </div>
        <div class="form-group">
          <label>collectibleDef <span class="hint">(auto-populated)</span></label>
          <input type="text" id="collectibleDef" placeholder="Auto-populated from selected word clue">
        </div>
        <div style="margin-top:14px;">
          <button class="btn btn-warning btn-block" onclick="exportWordJourney()">
            Word Journey JSON Export
          </button>
        </div>
      </div>
    </div>

  </div>

  <!-- RIGHT PANEL -->
  <div class="right-panel">
    <div id="puzzleOutput">
      <div class="empty-state">
        <div class="icon">Grid</div>
        <h3>No puzzle yet</h3>
        <p>Add words in the left panel, then click "Generate Crossword" to create a puzzle.</p>
      </div>
    </div>
  </div>
</div>

<!-- Toast -->
<div class="toast" id="toast"></div>

<script>
// ============================================================
// STATE
// ============================================================
let currentPuzzle = null;   // { size, placements: [{word, clue, hint2, row, col, direction}] }
let wordCounter = 0;

// ============================================================
// KOREAN INTERSECTION MAP
// ============================================================
function buildIntersectionMap(words) {
  // Build a map of which words share characters (Korean syllables)
  const map = {};
  for (let i = 0; i < words.length; i++) {
    for (let j = i + 1; j < words.length; j++) {
      const w1 = words[i].word;
      const w2 = words[j].word;
      const shared = [];
      for (let a = 0; a < w1.length; a++) {
        for (let b = 0; b < w2.length; b++) {
          if (w1[a] === w2[b]) {
            shared.push({ i1: a, i2: b, char: w1[a] });
          }
        }
      }
      if (shared.length > 0) {
        const key = `${i}-${j}`;
        map[key] = shared;
      }
    }
  }
  return map;
}

// ============================================================
// GRID ENGINE
// ============================================================
class GridEngine {
  constructor(size) {
    this.size = size;
    this.grid = [];
    for (let r = 0; r < size; r++) {
      this.grid.push(new Array(size).fill(null));
    }
  }

  clone() {
    const g = new GridEngine(this.size);
    for (let r = 0; r < this.size; r++) {
      for (let c = 0; c < this.size; c++) {
        g.grid[r][c] = this.grid[r][c];
      }
    }
    return g;
  }

  canPlace(word, row, col, direction) {
    const chars = [...word];
    for (let i = 0; i < chars.length; i++) {
      const r = direction === 'down' ? row + i : row;
      const c = direction === 'across' ? col + i : col;
      if (r < 0 || r >= this.size || c < 0 || c >= this.size) return false;
      const cell = this.grid[r][c];
      if (cell !== null && cell !== chars[i]) return false;
    }
    return true;
  }

  hasIntersection(word, row, col, direction) {
    const chars = [...word];
    for (let i = 0; i < chars.length; i++) {
      const r = direction === 'down' ? row + i : row;
      const c = direction === 'across' ? col + i : col;
      if (this.grid[r][c] === chars[i]) return true;
    }
    return false;
  }

  checkAdjacency(word, row, col, direction) {
    const chars = [...word];
    for (let i = 0; i < chars.length; i++) {
      const r = direction === 'down' ? row + i : row;
      const c = direction === 'across' ? col + i : col;
      // Skip intersection cells
      if (this.grid[r][c] !== null) continue;
      // Check perpendicular neighbors
      if (direction === 'across') {
        for (const dr of [-1, 1]) {
          const nr = r + dr;
          if (nr >= 0 && nr < this.size && this.grid[nr][c] !== null) return false;
        }
      } else {
        for (const dc of [-1, 1]) {
          const nc = c + dc;
          if (nc >= 0 && nc < this.size && this.grid[r][nc] !== null) return false;
        }
      }
    }
    return true;
  }

  place(word, row, col, direction) {
    const undo = [];
    const chars = [...word];
    for (let i = 0; i < chars.length; i++) {
      const r = direction === 'down' ? row + i : row;
      const c = direction === 'across' ? col + i : col;
      undo.push({ r, c, old: this.grid[r][c] });
      this.grid[r][c] = chars[i];
    }
    return undo;
  }

  undoPlace(undoList) {
    for (const { r, c, old } of undoList) {
      this.grid[r][c] = old;
    }
  }

  findPlacements(word, mustIntersect) {
    const options = [];
    for (const dir of ['across', 'down']) {
      for (let r = 0; r < this.size; r++) {
        for (let c = 0; c < this.size; c++) {
          if (!this.canPlace(word, r, c, dir)) continue;
          if (mustIntersect && !this.hasIntersection(word, r, c, dir)) continue;
          if (!this.checkAdjacency(word, r, c, dir)) continue;
          options.push({ row: r, col: c, direction: dir });
        }
      }
    }
    return options;
  }
}

// ============================================================
// CROSSWORD SOLVER (multi-attempt with backtracking)
// ============================================================
function shuffleArray(arr) {
  const a = [...arr];
  for (let i = a.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}

function backtrackPlace(engine, words, idx, placements) {
  if (idx >= words.length) return true;
  const word = words[idx].word;
  const mustIntersect = idx > 0;
  let options = engine.findPlacements(word, mustIntersect);
  options = shuffleArray(options);

  for (const opt of options) {
    const undo = engine.place(word, opt.row, opt.col, opt.direction);
    placements.push({
      word: word,
      clue: words[idx].clue || '',
      hint2: words[idx].hint2 || '',
      row: opt.row,
      col: opt.col,
      direction: opt.direction
    });

    if (backtrackPlace(engine, words, idx + 1, placements)) return true;

    placements.pop();
    engine.undoPlace(undo);
  }
  return false;
}

function solveCrossword(words, gridSize, maxAttempts = 100) {
  for (let attempt = 0; attempt < maxAttempts; attempt++) {
    const engine = new GridEngine(gridSize);
    const placements = [];
    const shuffled = shuffleArray(words);

    if (backtrackPlace(engine, shuffled, 0, placements)) {
      return { size: gridSize, placements, grid: engine.grid };
    }
  }
  return null;
}

// ============================================================
// ASSIGN NUMBERS
// ============================================================
function assignNumbers(placements) {
  // Collect all start positions
  const starts = new Map();
  for (const p of placements) {
    const key = `${p.row},${p.col}`;
    if (!starts.has(key)) {
      starts.set(key, { row: p.row, col: p.col });
    }
  }
  // Sort by row then col
  const sorted = [...starts.values()].sort((a, b) => a.row - b.row || a.col - b.col);
  const numMap = new Map();
  sorted.forEach((s, i) => {
    numMap.set(`${s.row},${s.col}`, i + 1);
  });
  return numMap;
}

// ============================================================
// GENERATE PUZZLE (main entry)
// ============================================================
function generatePuzzle() {
  const words = getWordsFromUI();
  if (words.length < 2) {
    showStatus('generateStatus', 'At least 2 words required.', 'danger');
    return;
  }

  const gridSize = parseInt(document.getElementById('gridSizeSelect').value);

  // Validate word lengths
  for (const w of words) {
    if (w.word.length > gridSize) {
      showStatus('generateStatus', `Word "${w.word}" (${w.word.length} chars) exceeds grid size ${gridSize}.`, 'danger');
      return;
    }
    if (w.word.length < 2) {
      showStatus('generateStatus', `Word "${w.word}" is too short (min 2 chars).`, 'danger');
      return;
    }
  }

  showStatus('generateStatus', 'Generating crossword...', 'info');
  document.getElementById('generateBtn').disabled = true;

  // Use setTimeout to allow UI to update
  setTimeout(() => {
    const result = solveCrossword(words, gridSize, 200);

    if (!result) {
      showStatus('generateStatus', 'Failed to find a valid layout. Try different words or a larger grid.', 'danger');
      document.getElementById('generateBtn').disabled = false;
      return;
    }

    currentPuzzle = result;
    showStatus('generateStatus', `Puzzle generated! ${result.placements.length} words placed on ${gridSize}x${gridSize} grid.`, 'success');
    document.getElementById('generateBtn').disabled = false;
    renderPuzzle(result);
    showExportCard(result);
  }, 50);
}

// ============================================================
// RENDER PUZZLE (grid + clues)
// ============================================================
function renderPuzzle(puzzle) {
  const { size, placements, grid } = puzzle;
  const numMap = assignNumbers(placements);

  // Track which cells are intersections
  const cellCount = {};
  for (const p of placements) {
    const chars = [...p.word];
    for (let i = 0; i < chars.length; i++) {
      const r = p.direction === 'down' ? p.row + i : p.row;
      const c = p.direction === 'across' ? p.col + i : p.col;
      const key = `${r},${c}`;
      cellCount[key] = (cellCount[key] || 0) + 1;
    }
  }

  // Build grid HTML
  let gridHTML = `<div class="grid-container" style="grid-template-columns: repeat(${size}, 48px);">`;
  for (let r = 0; r < size; r++) {
    for (let c = 0; c < size; c++) {
      const ch = grid[r][c];
      const key = `${r},${c}`;
      if (ch === null) {
        gridHTML += `<div class="cell empty"></div>`;
      } else {
        const isIntersection = (cellCount[key] || 0) > 1;
        let cls = 'cell filled';
        if (isIntersection) cls += ' intersection';
        const numHTML = numMap.has(key) ? `<span class="cell-num">${numMap.get(key)}</span>` : '';
        gridHTML += `<div class="${cls}" data-char="${ch}">${numHTML}<span class="char-text">${ch}</span></div>`;
      }
    }
  }
  gridHTML += `</div>`;

  // Toggle
  const toggleHTML = `
    <div class="toggle-row">
      <span class="toggle-label">Show Answers</span>
      <label class="toggle">
        <input type="checkbox" id="answerToggle" checked onchange="toggleAnswers(this.checked)">
        <span class="toggle-slider"></span>
      </label>
    </div>`;

  // Clues
  const across = placements.filter(p => p.direction === 'across');
  const down = placements.filter(p => p.direction === 'down');

  function clueHTML(list, label) {
    if (list.length === 0) return '';
    let html = `<div class="clue-group"><h3>${label}</h3>`;
    for (const p of list) {
      const num = numMap.get(`${p.row},${p.col}`) || '?';
      html += `<div class="clue-item">
        <div class="clue-word">${num}. ${p.word}</div>
        <div class="clue-text">${p.clue}</div>
        ${p.hint2 ? `<div class="clue-hint2">${p.hint2}</div>` : ''}
      </div>`;
    }
    html += `</div>`;
    return html;
  }

  const output = document.getElementById('puzzleOutput');
  output.innerHTML = `
    <div class="card">
      <div class="card-header">
        <h2>Crossword Preview</h2>
        <div class="btn-group">
          <button class="btn btn-secondary btn-sm" onclick="printPuzzle()">Print</button>
          <button class="btn btn-secondary btn-sm" onclick="exportExcel()">Excel</button>
          <button class="btn btn-secondary btn-sm" onclick="exportJSON()">JSON</button>
        </div>
      </div>
      <div class="card-body">
        <div class="grid-wrapper">
          ${gridHTML}
          ${toggleHTML}
        </div>
      </div>
    </div>
    <div class="card">
      <div class="card-header"><h2>Clues</h2></div>
      <div class="card-body">
        <div class="clues-section">
          ${clueHTML(across, 'Across (Horizontal)')}
          ${clueHTML(down, 'Down (Vertical)')}
        </div>
      </div>
    </div>`;
}

function toggleAnswers(show) {
  document.querySelectorAll('.cell.filled .char-text').forEach(el => {
    el.style.color = show ? 'var(--text-primary)' : 'transparent';
  });
}

// ============================================================
// SHOW EXPORT CARD (Word Journey Step 3)
// ============================================================
function showExportCard(puzzle) {
  const card = document.getElementById('exportCard');
  card.style.display = 'block';

  // Populate collectible word dropdown
  const select = document.getElementById('collectibleWord');
  select.innerHTML = '<option value="">-- Select --</option>';
  for (const p of puzzle.placements) {
    const opt = document.createElement('option');
    opt.value = p.word;
    opt.textContent = p.word;
    select.appendChild(opt);
  }

  // Auto-select first word
  if (puzzle.placements.length > 0) {
    select.value = puzzle.placements[0].word;
    updateCollectibleDef();
  }

  // Set up auto-population of collectibleDef
  select.onchange = updateCollectibleDef;

  // Pre-fill from narrative
  const narrative = document.getElementById('narrativeInput').value.trim();
  if (narrative && !document.getElementById('chapterTitle').value) {
    // Leave empty for user to fill
  }
}

function updateCollectibleDef() {
  const word = document.getElementById('collectibleWord').value;
  if (!word || !currentPuzzle) return;
  const placement = currentPuzzle.placements.find(p => p.word === word);
  if (placement) {
    document.getElementById('collectibleDef').value = placement.clue || '';
  }
}

// ============================================================
// WORD JOURNEY JSON EXPORT
// ============================================================
function exportWordJourney() {
  if (!currentPuzzle) {
    showToast('Generate a puzzle first!');
    return;
  }

  const chapterId = parseInt(document.getElementById('chapterId').value) || 11;
  const title = document.getElementById('chapterTitle').value.trim();
  const subtitle = document.getElementById('chapterSubtitle').value.trim();
  const avatarMood = parseInt(document.getElementById('avatarMood').value);
  const accentColor = document.getElementById('accentColorText').value.trim();
  const completionIllust = document.getElementById('completionIllust').value.trim() || '✨';
  const completionNarrative = document.getElementById('completionNarrative').value.trim();
  const collectibleWord = document.getElementById('collectibleWord').value;
  const collectibleDef = document.getElementById('collectibleDef').value.trim();
  const collectibleRarity = document.getElementById('collectibleRarity').value;

  // Build narrative intro from the input (JSON.stringify will handle \n encoding)
  const narrativeRaw = document.getElementById('narrativeInput').value.trim();
  const narrativeIntro = narrativeRaw.replace(/\r\n/g, '\n');

  // Build words array
  const words = currentPuzzle.placements.map(p => {
    const wordStr = p.word;
    // Auto-generate hint2 if not provided
    let hint2 = p.hint2 || '';
    if (!hint2) {
      hint2 = '"' + '\uBB38\uC7A5\uC5D0\uC11C ' + '\u25CB'.repeat(wordStr.length) + ' \uC0AC\uC6A9."';
    }
    // hint3char: first character
    const hint3char = { index: 0, char: [...wordStr][0] };

    return {
      word: wordStr,
      clue: p.clue || '',
      hint2: hint2,
      hint3char: hint3char,
      direction: p.direction,
      row: p.row,
      col: p.col
    };
  });

  // Compute grid size
  let maxR = 0, maxC = 0;
  for (const p of currentPuzzle.placements) {
    const chars = [...p.word];
    for (let i = 0; i < chars.length; i++) {
      const r = p.direction === 'down' ? p.row + i : p.row;
      const c = p.direction === 'across' ? p.col + i : p.col;
      if (r + 1 > maxR) maxR = r + 1;
      if (c + 1 > maxC) maxC = c + 1;
    }
  }
  const gridSize = Math.max(maxR, maxC);

  const chapter = {
    id: chapterId,
    title: title,
    subtitle: subtitle,
    avatarMood: avatarMood,
    accentColor: accentColor,
    narrativeIntro: narrativeIntro,
    completionIllust: completionIllust,
    completionNarrative: completionNarrative,
    crossword: {
      size: gridSize,
      words: words,
      collectibleWord: collectibleWord,
      collectibleDef: collectibleDef,
      collectibleRarity: collectibleRarity
    }
  };

  // Download
  const jsonStr = JSON.stringify(chapter, null, 2);
  const blob = new Blob([jsonStr], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `chapter_${String(chapterId).padStart(2, '0')}.json`;
  a.click();
  URL.revokeObjectURL(url);

  showToast(`chapter_${String(chapterId).padStart(2, '0')}.json downloaded!`);
}

// ============================================================
// AI WORD EXTRACTION (Claude API)
// ============================================================
async function aiExtractWords() {
  const apiKey = document.getElementById('apiKey').value.trim();
  const narrative = document.getElementById('narrativeInput').value.trim();
  const difficulty = parseInt(document.getElementById('difficultySelect').value);
  const gridSize = parseInt(document.getElementById('gridSizeSelect').value);
  const wordCount = parseInt(document.getElementById('wordCountInput').value);

  if (!narrative) {
    showStatus('aiStatus', 'Please enter narrative text.', 'danger');
    return;
  }
  if (!apiKey) {
    showStatus('aiStatus', 'Please enter your Anthropic API key.', 'danger');
    return;
  }

  const maxWordLen = gridSize <= 6 ? 3 : 4;
  const extra = wordCount;

  const prompt = `\uB2F9\uC2E0\uC740 \uD55C\uAD6D\uC5B4 \uD55C\uC790\uC5B4 \uB2E8\uC5B4 \uC804\uBB38\uAC00\uC774\uC790 \uC2ED\uC790\uB0B1\uB9D0 \uD37C\uC990 \uC124\uACC4\uC790\uC785\uB2C8\uB2E4.

\uC8FC\uC5B4\uC9C4 \uC11C\uC0AC(narrative)\uB97C \uC77D\uACE0, \uADF8 \uBD84\uC704\uAE30\uC640 \uAC10\uC815\uC5D0 \uC5B4\uC6B8\uB9AC\uB294 \uD55C\uC790\uC5B4 \uB2E8\uC5B4\uB4E4\uC744 \uCD94\uCD9C\uD574\uC8FC\uC138\uC694.
\uC774 \uB2E8\uC5B4\uB4E4\uC740 ${gridSize}x${gridSize} \uD06C\uB85C\uC2A4\uC6CC\uB4DC \uD37C\uC990\uC5D0 \uBC30\uCE58\uB429\uB2C8\uB2E4.

## \uC11C\uC0AC
"""
${narrative}
"""

## \uC694\uAD6C\uC0AC\uD56D

### \uB2E8\uC5B4 \uCD94\uCD9C (${wordCount + extra}\uAC1C)
- \uB2E8\uC5B4 \uAE38\uC774: 2~${maxWordLen}\uAE00\uC790 \uD55C\uC790\uC5B4\uB9CC
- \uC11C\uC0AC\uC758 \uBD84\uC704\uAE30/\uAC10\uC815\uACFC \uBC00\uC811\uD558\uAC8C \uC5F0\uAD00\uB41C \uB2E8\uC5B4
- **\uC911\uC694**: \uB2E8\uC5B4\uB4E4 \uC0AC\uC774\uC5D0 \uACF5\uC720\uB418\uB294 \uD55C\uAE00 \uC74C\uC808\uC774 \uC788\uC5B4\uC57C \uD569\uB2C8\uB2E4 (\uD06C\uB85C\uC2A4\uC6CC\uB4DC \uAD50\uCC28\uC6A9)
  \uC608: "\uACF5\uD5C8"\uC640 "\uD5C8\uBB34"\uB294 "\uD5C8"\uB97C \uACF5\uC720, "\uD5C8\uBB34"\uC640 "\uBB34\uC2EC"\uC740 "\uBB34"\uB97C \uACF5\uC720
- \uCD5C\uC18C ${wordCount}\uAC1C\uB294 \uCCB4\uC778\uCC98\uB7FC \uC5F0\uACB0 \uAC00\uB2A5\uD574\uC57C \uD568
- \uB09C\uC774\uB3C4 ${difficulty}/5: ${difficulty <= 2 ? '\uC77C\uC0C1\uC801\uC774\uACE0 \uC26C\uC6B4 \uB2E8\uC5B4' : difficulty === 3 ? '\uBCF4\uD1B5 \uB09C\uC774\uB3C4\uC758 \uB2E8\uC5B4' : '\uCD94\uC0C1\uC801\uC774\uACE0 \uACE0\uAE09\uC2A4\uB7EC\uC6B4 \uB2E8\uC5B4'}

### \uCC55\uD130 \uBA54\uD0C0\uB370\uC774\uD130
\uC11C\uC0AC\uC5D0 \uC5B4\uC6B8\uB9AC\uB294 \uCC55\uD130 \uC81C\uBAA9\uACFC \uBD80\uC81C, \uC644\uB8CC \uC2DC \uB0B4\uB7EC\uD2F0\uBE0C\uB3C4 \uC81C\uC548\uD574\uC8FC\uC138\uC694.

## \uC751\uB2F5 \uD615\uC2DD (\uBC18\uB4DC\uC2DC \uC774 JSON \uD615\uC2DD\uB9CC \uCD9C\uB825)
\`\`\`json
{
  "words": [
    {
      "word": "\uACF5\uD5C8",
      "hanja": "\u7A7A\u865B",
      "definition": "\uB9C8\uC74C\uC18D\uC774 \uD5DB \uBE44\uC5B4 \uC788\uB294 \uB290\uB08C",
      "exampleSentence": "\uC131\uACF5\uC744 \uC774\uB904\uC9C0\uB9CC \uB9C8\uC74C\uC740 \u25CB\u25CB\uD588\uB2E4.",
      "hint2": "\uC131\uACF5\uC744 \uC774\uB984\uC9C0\uB9CC \uB9C8\uC74C\uC740 \u25CB\u25CB\uD588\uB2E4."
    }
  ],
  "metadata": {
    "title": "\uC7BF\uBE5B \uC0C8\uBCBD",
    "subtitle": "\uC544\uBB34\uAC83\uB3C4 \uB290\uB07C\uC9C0 \uBABB\uD558\uB294 \uB0A0\uB4E4",
    "completionIllust": "\uD83C\uDF2B\uFE0F",
    "completionNarrative": "\uD5DB \uBE48 \uC0C8\uBCBD,\\n\uCC98\uC74C\uC73C\uB85C \uBB34\uC5B8\uAC00\uB97C \uB290\uBF08\uB2E4.\\n\uADF8\uAC83\uC774 \uBE44\uB85D \uACF5\uD5C8\uC77C\uC9C0\uB77C\uB3C4.",
    "suggestedCollectible": "\uACF5\uD5C8",
    "collectibleReason": "\uC11C\uC0AC\uC758 \uD575\uC2EC \uAC10\uC815\uC744 \uB300\uD45C"
  }
}
\`\`\`

\uC815\uD655\uD788 ${wordCount + extra}\uAC1C\uC758 \uB2E8\uC5B4\uB97C \uC81C\uACF5\uD574\uC8FC\uC138\uC694. JSON\uB9CC \uCD9C\uB825\uD558\uACE0 \uB2E4\uB978 \uD14D\uC2A4\uD2B8\uB294 \uD3EC\uD568\uD558\uC9C0 \uB9C8\uC138\uC694.`;

  showStatus('aiStatus', '<span class="spinner"></span> Calling Claude API...', 'info');
  document.getElementById('aiExtractBtn').disabled = true;

  try {
    const response = await fetch('https://api.anthropic.com/v1/messages', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'x-api-key': apiKey,
        'anthropic-version': '2023-06-01',
        'anthropic-dangerous-direct-browser-access': 'true'
      },
      body: JSON.stringify({
        model: 'claude-sonnet-4-5-20250514',
        max_tokens: 4000,
        messages: [{ role: 'user', content: prompt }]
      })
    });

    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }

    const data = await response.json();
    let text = data.content[0].text.trim();

    // Remove markdown code fences if present
    if (text.startsWith('```')) {
      const lines = text.split('\n');
      const filtered = lines.filter(l => !l.trim().startsWith('```'));
      text = filtered.join('\n');
    }

    const result = JSON.parse(text);

    if (!result.words || !Array.isArray(result.words)) {
      throw new Error('Invalid response: missing words array');
    }

    // Populate word entries
    clearWordList();
    for (const w of result.words) {
      // Build hint2 from the response or from exampleSentence
      let hint2 = w.hint2 || '';
      if (!hint2 && w.exampleSentence) {
        hint2 = w.exampleSentence.replace(w.word, '\u25CB'.repeat(w.word.length));
      }
      addWordEntry(w.word, `${w.definition}. ${w.hanja || ''}.`.replace(/\.\s*\./g, '.'), hint2);
    }

    // Populate metadata if available
    if (result.metadata) {
      const m = result.metadata;
      if (m.title) document.getElementById('chapterTitle').value = m.title;
      if (m.subtitle) document.getElementById('chapterSubtitle').value = m.subtitle;
      if (m.completionIllust) document.getElementById('completionIllust').value = m.completionIllust;
      if (m.completionNarrative) document.getElementById('completionNarrative').value = m.completionNarrative.replace(/\\n/g, '\n');
    }

    showStatus('aiStatus', `Extracted ${result.words.length} words from AI.`, 'success');
  } catch (err) {
    console.error('AI extraction error:', err);
    let errorMsg = `AI extraction failed: ${err.message}`;

    // Detect CORS errors
    if (err.message.includes('Failed to fetch') || err.message.includes('NetworkError') || err.message.includes('CORS')) {
      errorMsg = `<strong>CORS Error:</strong> Browser direct API calls are blocked by Anthropic's CORS policy.<br><br>
        <strong>Options:</strong><br>
        1. Use a CORS proxy (e.g., add <code>https://cors-anywhere.herokuapp.com/</code> prefix)<br>
        2. Manually enter words below using the "Add Word" button<br>
        3. Upload a JSON word list file<br>
        4. Use this tool via a local server with proxy support`;
    }
    showStatus('aiStatus', errorMsg, 'danger');
  } finally {
    document.getElementById('aiExtractBtn').disabled = false;
  }
}

// ============================================================
// WORD LIST MANAGEMENT
// ============================================================
function addWordEntry(word = '', clue = '', hint2 = '') {
  wordCounter++;
  const container = document.getElementById('wordList');
  const div = document.createElement('div');
  div.className = 'word-entry';
  div.dataset.id = wordCounter;
  div.innerHTML = `
    <div class="word-row">
      <span class="word-num">${wordCounter}</span>
      <input type="text" class="word-input" placeholder="Word" value="${escapeHTML(word)}">
      <input type="text" class="clue-input" placeholder="Clue (definition)" value="${escapeHTML(clue)}">
      <button class="remove-btn" onclick="removeWordEntry(this)" title="Remove">&times;</button>
    </div>
    <div class="word-row" style="margin-bottom:0; padding-left:26px;">
      <input type="text" class="hint2-input" placeholder="Hint2 (example sentence with masking)" value="${escapeHTML(hint2)}">
    </div>`;
  container.appendChild(div);
}

function removeWordEntry(btn) {
  btn.closest('.word-entry').remove();
  renumberWords();
}

function renumberWords() {
  document.querySelectorAll('#wordList .word-entry').forEach((entry, i) => {
    entry.querySelector('.word-num').textContent = i + 1;
  });
}

function clearWordList() {
  document.getElementById('wordList').innerHTML = '';
  wordCounter = 0;
}

function getWordsFromUI() {
  const entries = document.querySelectorAll('#wordList .word-entry');
  const words = [];
  entries.forEach(entry => {
    const word = entry.querySelector('.word-input').value.trim();
    const clue = entry.querySelector('.clue-input').value.trim();
    const hint2 = entry.querySelector('.hint2-input').value.trim();
    if (word) {
      words.push({ word, clue, hint2 });
    }
  });
  return words;
}

// ============================================================
// FILE UPLOAD / DOWNLOAD
// ============================================================
function handleFileUpload(event) {
  const file = event.target.files[0];
  if (!file) return;

  const reader = new FileReader();
  reader.onload = function(e) {
    try {
      const data = JSON.parse(e.target.result);

      // Support multiple formats
      let words = [];
      if (Array.isArray(data)) {
        words = data;
      } else if (data.words && Array.isArray(data.words)) {
        words = data.words;
      } else if (data.crossword && data.crossword.words) {
        words = data.crossword.words;
      }

      if (words.length === 0) {
        showToast('No words found in file.');
        return;
      }

      clearWordList();
      for (const w of words) {
        const word = w.word || '';
        const clue = w.clue || w.definition || '';
        const hint2 = w.hint2 || w.exampleSentence || '';
        addWordEntry(word, clue, hint2);
      }

      // Populate metadata if present
      if (data.title) document.getElementById('chapterTitle').value = data.title;
      if (data.subtitle) document.getElementById('chapterSubtitle').value = data.subtitle;
      if (data.id) document.getElementById('chapterId').value = data.id;
      if (data.accentColor) {
        document.getElementById('accentColorText').value = data.accentColor;
        document.getElementById('accentColorPicker').value = data.accentColor;
      }
      if (data.completionIllust) document.getElementById('completionIllust').value = data.completionIllust;
      if (data.completionNarrative) document.getElementById('completionNarrative').value = data.completionNarrative;
      if (data.avatarMood !== undefined) document.getElementById('avatarMood').value = data.avatarMood;

      showToast(`Loaded ${words.length} words from file.`);
    } catch (err) {
      showToast('Failed to parse file: ' + err.message);
    }
  };
  reader.readAsText(file);

  // Reset file input
  event.target.value = '';
}

// Drag and drop
const dropZone = document.getElementById('dropZone');
dropZone.addEventListener('dragover', (e) => {
  e.preventDefault();
  dropZone.classList.add('drag-over');
});
dropZone.addEventListener('dragleave', () => {
  dropZone.classList.remove('drag-over');
});
dropZone.addEventListener('drop', (e) => {
  e.preventDefault();
  dropZone.classList.remove('drag-over');
  const file = e.dataTransfer.files[0];
  if (file) {
    const input = document.getElementById('fileInput');
    const dt = new DataTransfer();
    dt.items.add(file);
    input.files = dt.files;
    handleFileUpload({ target: input });
  }
});

// ============================================================
// EXPORT: Excel (TSV)
// ============================================================
function exportExcel() {
  if (!currentPuzzle) return;
  const { size, placements, grid } = currentPuzzle;

  // Grid as TSV
  let tsv = 'Grid:\n';
  for (let r = 0; r < size; r++) {
    const row = [];
    for (let c = 0; c < size; c++) {
      row.push(grid[r][c] || '');
    }
    tsv += row.join('\t') + '\n';
  }
  tsv += '\nWords:\n';
  tsv += 'Word\tClue\tHint2\tDirection\tRow\tCol\n';
  for (const p of placements) {
    tsv += `${p.word}\t${p.clue}\t${p.hint2 || ''}\t${p.direction}\t${p.row}\t${p.col}\n`;
  }

  downloadFile(tsv, 'crossword.tsv', 'text/tab-separated-values');
}

// ============================================================
// EXPORT: JSON (raw puzzle)
// ============================================================
function exportJSON() {
  if (!currentPuzzle) return;
  const data = {
    size: currentPuzzle.size,
    placements: currentPuzzle.placements.map(p => ({
      word: p.word,
      clue: p.clue,
      hint2: p.hint2 || '',
      direction: p.direction,
      row: p.row,
      col: p.col
    }))
  };
  const json = JSON.stringify(data, null, 2);
  downloadFile(json, 'crossword.json', 'application/json');
}

// ============================================================
// EXPORT: Print
// ============================================================
function printPuzzle() {
  if (!currentPuzzle) return;
  const { size, placements, grid } = currentPuzzle;
  const numMap = assignNumbers(placements);

  // Track intersections
  const cellCount = {};
  for (const p of placements) {
    const chars = [...p.word];
    for (let i = 0; i < chars.length; i++) {
      const r = p.direction === 'down' ? p.row + i : p.row;
      const c = p.direction === 'across' ? p.col + i : p.col;
      const key = `${r},${c}`;
      cellCount[key] = (cellCount[key] || 0) + 1;
    }
  }

  let html = `<!DOCTYPE html><html><head><meta charset="UTF-8">
<title>Crossword Puzzle</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700&display=swap');
  body { font-family: 'Noto Sans KR', sans-serif; padding: 40px; }
  .grid { display: inline-grid; grid-template-columns: repeat(${size}, 44px); gap: 2px; }
  .cell { width: 44px; height: 44px; border: 1px solid #ddd; display: flex; align-items: center; justify-content: center; font-size: 18px; font-weight: 700; position: relative; }
  .cell.empty { background: #333; }
  .cell .num { position: absolute; top: 1px; left: 3px; font-size: 8px; color: #999; }
  .clues { margin-top: 24px; }
  .clues h3 { margin: 16px 0 8px; }
  .clue { margin: 4px 0; font-size: 14px; }
  @media print { body { padding: 20px; } }
</style>
</head><body>
<h2>Crossword Puzzle</h2>
<div class="grid">`;

  for (let r = 0; r < size; r++) {
    for (let c = 0; c < size; c++) {
      const ch = grid[r][c];
      const key = `${r},${c}`;
      if (ch === null) {
        html += `<div class="cell empty"></div>`;
      } else {
        const numHTML = numMap.has(key) ? `<span class="num">${numMap.get(key)}</span>` : '';
        html += `<div class="cell">${numHTML}</div>`;
      }
    }
  }

  html += `</div><div class="clues">`;

  const across = placements.filter(p => p.direction === 'across');
  const down = placements.filter(p => p.direction === 'down');

  if (across.length) {
    html += '<h3>Across (Horizontal)</h3>';
    for (const p of across) {
      const num = numMap.get(`${p.row},${p.col}`) || '?';
      html += `<div class="clue"><strong>${num}.</strong> ${p.clue}</div>`;
      if (p.hint2) html += `<div class="clue" style="color:#888;font-style:italic;margin-left:20px;">${p.hint2}</div>`;
    }
  }
  if (down.length) {
    html += '<h3>Down (Vertical)</h3>';
    for (const p of down) {
      const num = numMap.get(`${p.row},${p.col}`) || '?';
      html += `<div class="clue"><strong>${num}.</strong> ${p.clue}</div>`;
      if (p.hint2) html += `<div class="clue" style="color:#888;font-style:italic;margin-left:20px;">${p.hint2}</div>`;
    }
  }

  html += `</div></body></html>`;

  const win = window.open('', '_blank');
  win.document.write(html);
  win.document.close();
  win.setTimeout(() => win.print(), 500);
}

// ============================================================
// DOWNLOAD TEMPLATE
// ============================================================
function downloadTemplate() {
  const template = {
    words: [
      { word: "\uACF5\uD5C8", clue: "\uB9C8\uC74C\uC18D\uC774 \uD5DB \uBE44\uC5B4 \uC788\uB294 \uB290\uB08C. \u7A7A\u865B.", hint2: '"\uC131\uACF5\uC744 \uC774\uB984\uC9C0\uB9CC \uB9C8\uC74C\uC740 \u25CB\u25CB\uD588\uB2E4."' },
      { word: "\uD5C8\uBB34", clue: "\uB9E4\uC6B0 \uD5DB\uB418\uACE0 \uBCF4\uC7A8\uAC83\uC5C6\uC74C. \u865B\u7121.", hint2: '"\uC0B6\uC774 \u25CB\u25CB\uD558\uAC8C \uB290\uAEF4\uC84C\uB2E4."' },
      { word: "\uBB34\uC2EC", clue: "\uAD00\uC2EC\uC774\uB098 \uD765\uBBF8\uAC00 \uC5C6\uC74C. \u7121\u5FC3.", hint2: '"\uADF8\uB294 \u25CB\u25CB\uD558\uAC8C \uCC3D\uBC16\uC744 \uBC14\uB77C\uBCF4\uC558\uB2E4."' }
    ]
  };
  const json = JSON.stringify(template, null, 2);
  downloadFile(json, 'word-template.json', 'application/json');
}

// ============================================================
// UTILITIES
// ============================================================
function downloadFile(content, filename, mimeType) {
  const blob = new Blob([content], { type: mimeType });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  a.click();
  URL.revokeObjectURL(url);
}

function showStatus(elementId, message, type) {
  const el = document.getElementById(elementId);
  el.style.display = 'block';
  el.className = `alert alert-${type}`;
  el.innerHTML = message;
}

function showToast(message) {
  const toast = document.getElementById('toast');
  toast.textContent = message;
  toast.classList.add('show');
  setTimeout(() => toast.classList.remove('show'), 3000);
}

function escapeHTML(str) {
  return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
}

// ============================================================
// INIT: Add some default entries
// ============================================================
addWordEntry();
addWordEntry();
addWordEntry();
</script>
</body>
</html>
